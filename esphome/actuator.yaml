esphome:
  name: radiant-heat-controller
  friendly_name: Radiant Heat Controller
  on_boot:
    priority: -100
    then:
      # Log reset reason for debugging unexpected restarts
      - lambda: |-
          esp_reset_reason_t reason = esp_reset_reason();
          const char* reason_str;
          switch (reason) {
            case ESP_RST_POWERON:   reason_str = "Power-on reset"; break;
            case ESP_RST_EXT:       reason_str = "External reset (RST pin)"; break;
            case ESP_RST_SW:        reason_str = "Software reset (esp_restart)"; break;
            case ESP_RST_PANIC:     reason_str = "Exception/panic reset"; break;
            case ESP_RST_INT_WDT:   reason_str = "Interrupt watchdog reset"; break;
            case ESP_RST_TASK_WDT:  reason_str = "Task watchdog reset"; break;
            case ESP_RST_WDT:       reason_str = "Other watchdog reset"; break;
            case ESP_RST_DEEPSLEEP: reason_str = "Deep sleep reset"; break;
            case ESP_RST_BROWNOUT:  reason_str = "Brownout reset (low voltage)"; break;
            case ESP_RST_SDIO:      reason_str = "SDIO reset"; break;
            default:                reason_str = "Unknown"; break;
          }
          ESP_LOGW("boot", "=== RESET REASON: %s ===", reason_str);
          if (reason == ESP_RST_PANIC || reason == ESP_RST_INT_WDT ||
              reason == ESP_RST_TASK_WDT || reason == ESP_RST_WDT) {
            ESP_LOGE("boot", "!!! ABNORMAL RESET DETECTED - Check for bugs !!!");
          }
          if (reason == ESP_RST_BROWNOUT) {
            ESP_LOGE("boot", "!!! BROWNOUT - Check power supply !!!");
          }
      # Initialize all zones with global setpoint on boot
      - lambda: |-
          auto setpoint = id(global_setpoint).state;
          id(zone1_climate).target_temperature = setpoint;
          id(zone2_climate).target_temperature = setpoint;
          id(zone3_climate).target_temperature = setpoint;
          id(zone4_climate).target_temperature = setpoint;
          id(zone5_climate).target_temperature = setpoint;
          id(zone6_climate).target_temperature = setpoint;
          id(zone7_climate).target_temperature = setpoint;

# Global variable to track if pump should be running
globals:
  - id: pump_demand
    type: bool
    restore_value: no
    initial_value: 'false'

  # Temperature history for graphs (40 samples = 20 min at 30s interval)
  - id: temp_history_1
    type: float[40]
    restore_value: no
  - id: temp_history_2
    type: float[40]
    restore_value: no
  - id: temp_history_3
    type: float[40]
    restore_value: no
  - id: temp_history_4
    type: float[40]
    restore_value: no
  - id: temp_history_5
    type: float[40]
    restore_value: no
  - id: temp_history_6
    type: float[40]
    restore_value: no
  - id: temp_history_7
    type: float[40]
    restore_value: no

  # Pump status history for binary graph
  - id: pump_history
    type: bool[40]
    restore_value: no

  # History write index
  - id: history_index
    type: int
    restore_value: no
    initial_value: '0'

  # Failsafe: per-zone error scores (0-100, triggers safety error at threshold)
  - id: zone_error_scores
    type: int[7]
    restore_value: no

  # Failsafe: reference temperature when heating started (for tracking rise)
  - id: zone_heat_ref_temps
    type: float[7]
    restore_value: no

  # Failsafe: heating duration counter (increments every 30s while heating)
  - id: zone_heat_duration
    type: int[7]
    restore_value: no

  # Failsafe: valve timeout counter (increments while relay on but valve not open)
  - id: zone_valve_timeout
    type: int[7]
    restore_value: no

# Waveshare ESP32-S3-ETH-8DI-8RO board
# https://devices.esphome.io/devices/waveshare-esp32-s3-eth-8di-8do/
esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable PSRAM (8MB available on ESP32-S3-WROOM-1U-N16R8)
psram:
  mode: octal
  speed: 80MHz

logger:
  level: INFO

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

# Ethernet (W5500 on Waveshare board) - disabled, using WiFi instead
# ethernet:
#   type: W5500
#   clk_pin: GPIO15
#   mosi_pin: GPIO13
#   miso_pin: GPIO14
#   cs_pin: GPIO16
#   interrupt_pin: GPIO12
#   reset_pin: GPIO39

# WiFi as primary network interface
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "RadiantHeat Fallback"
    password: !secret fallback_ap_password

captive_portal:

web_server:
  port: 80

# I2C bus for PCA9554 (relay expander), DS2484 (1-wire master), and PCF85063 (RTC)
# Waveshare board I2C pins: SDA=GPIO42, SCL=GPIO41
i2c:
  sda: GPIO42
  scl: GPIO41
  scan: true
  frequency: 100kHz

# PCA9554 I/O expander for relay control (address 0x20)
# Waveshare board uses PCA9554; ESPHome's pca9554 component is register-compatible
pca9554:
  - id: relay_expander
    address: 0x20

# XL9535 I/O expander for additional zones (OPTIONAL - uncomment when adding expansion board)
# Address options: 0x20-0x27 depending on A0/A1/A2 pins
# xl9535:
#   - id: expansion_relays
#     address: 0x21  # Use different address than TCA9554

# DS2484 1-wire master for temperature sensors (Adafruit DS2484 breakout)
# Default I2C address: 0x18
one_wire:
  - platform: ds2484
    id: onewire_bus

# Global setpoint that can be applied to all zones (in Celsius)
number:
  - platform: template
    name: "Global Setpoint"
    id: global_setpoint
    unit_of_measurement: "°C"
    device_class: temperature
    optimistic: true
    min_value: 10
    max_value: 30
    step: 0.5
    initial_value: 20
    restore_value: false  # Disabled to reset from old °F values - can re-enable later
    on_value:
      then:
        - lambda: |-
            // Only apply to zones that haven't been individually overridden
            // Users can set per-zone temps via HA which won't be overwritten
            ESP_LOGI("thermostat", "Global setpoint changed to %.1f°C", x);

  - platform: template
    name: "Apply Global Setpoint"
    id: apply_global_trigger
    unit_of_measurement: ""
    optimistic: true
    min_value: 0
    max_value: 1
    step: 1
    initial_value: 0
    on_value:
      then:
        - if:
            condition:
              lambda: 'return x == 1;'
            then:
              - lambda: |-
                  auto setpoint = id(global_setpoint).state;
                  id(zone1_climate).target_temperature = setpoint;
                  id(zone2_climate).target_temperature = setpoint;
                  id(zone3_climate).target_temperature = setpoint;
                  id(zone4_climate).target_temperature = setpoint;
                  id(zone5_climate).target_temperature = setpoint;
                  id(zone6_climate).target_temperature = setpoint;
                  id(zone7_climate).target_temperature = setpoint;
                  ESP_LOGI("thermostat", "Applied global setpoint %.1f°C to all zones", setpoint);
              - number.set:
                  id: apply_global_trigger
                  value: 0

  - platform: template
    name: "Pump Start Delay"
    id: pump_start_delay
    unit_of_measurement: "s"
    optimistic: true
    min_value: 0
    max_value: 60
    step: 1
    initial_value: 5
    restore_value: true

  - platform: template
    name: "Pump Stop Delay"
    id: pump_stop_delay
    unit_of_measurement: "s"
    optimistic: true
    min_value: 0
    max_value: 300
    step: 5
    initial_value: 30
    restore_value: true

# Hysteresis setting (configurable deadband)
  - platform: template
    name: "Thermostat Hysteresis"
    id: hysteresis
    unit_of_measurement: "°C"
    optimistic: true
    min_value: 0.5
    max_value: 3
    step: 0.5
    initial_value: 0.5
    restore_value: false  # Disabled to reset from old °F values

# Internal relay switches via PCA9554 expander
switch:
  - platform: gpio
    name: "Zone 1 Relay"
    id: zone1_relay
    pin:
      pca9554: relay_expander
      number: 0
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 2 Relay"
    id: zone2_relay
    pin:
      pca9554: relay_expander
      number: 1
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 3 Relay"
    id: zone3_relay
    pin:
      pca9554: relay_expander
      number: 2
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 4 Relay"
    id: zone4_relay
    pin:
      pca9554: relay_expander
      number: 3
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 5 Relay"
    id: zone5_relay
    pin:
      pca9554: relay_expander
      number: 4
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 6 Relay"
    id: zone6_relay
    pin:
      pca9554: relay_expander
      number: 5
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  - platform: gpio
    name: "Zone 7 Relay"
    id: zone7_relay
    pin:
      pca9554: relay_expander
      number: 6
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

  # Relay 8 (index 7) is used for circulation pump control
  - platform: gpio
    name: "Circulation Pump Relay"
    id: pump_relay
    pin:
      pca9554: relay_expander
      number: 7
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true

# Expansion zone relays via XL9535 (OPTIONAL - uncomment when adding expansion board)
# switch (continued):
#   - platform: gpio
#     name: "Zone 8 Relay"
#     id: zone8_relay
#     pin:
#       xl9535: expansion_relays
#       number: 0
#       mode: OUTPUT
#     restore_mode: RESTORE_DEFAULT_OFF
#     internal: true
#   - platform: gpio
#     name: "Zone 9 Relay"
#     id: zone9_relay
#     pin:
#       xl9535: expansion_relays
#       number: 1
#       mode: OUTPUT
#     restore_mode: RESTORE_DEFAULT_OFF
#     internal: true
#   # ... continue for zones 10-16 on pins 2-7 and 8-15

# Dallas/DS18B20 temperature sensors on the 1-wire bus
# NOTE: Replace the 0x0000000000000000 addresses with your actual sensor addresses
# Run once with these placeholders, check logs for discovered addresses, then update
sensor:
  - platform: dallas_temp
    one_wire_id: onewire_bus
    index: 0  # First discovered sensor - check logs for actual address
    name: "Zone 1 Temperature"
    id: zone1_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone1_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    index: 1  # Second discovered sensor - check logs for actual address
    name: "Zone 2 Temperature"
    id: zone2_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone2_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    address: 0x0000000000000003  # Replace with actual address
    name: "Zone 3 Temperature"
    id: zone3_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone3_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    address: 0x0000000000000004  # Replace with actual address
    name: "Zone 4 Temperature"
    id: zone4_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone4_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    address: 0x0000000000000005  # Replace with actual address
    name: "Zone 5 Temperature"
    id: zone5_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone5_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    address: 0x0000000000000006  # Replace with actual address
    name: "Zone 6 Temperature"
    id: zone6_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone6_climate).current_temperature = x;

  - platform: dallas_temp
    one_wire_id: onewire_bus
    address: 0x0000000000000007  # Replace with actual address
    name: "Zone 7 Temperature"
    id: zone7_temp
    unit_of_measurement: "°C"
    on_value:
      then:
        - lambda: |-
            id(zone7_climate).current_temperature = x;

# Zone 8 sensor available for expansion via XL9535
# Uncomment and add address when expansion board is installed
#   - platform: dallas_temp
#     one_wire_id: onewire_bus
#     address: 0x0000000000000008  # Replace with actual address
#     name: "Zone 8 Temperature"
#     id: zone8_temp
#     unit_of_measurement: "°F"
#     filters:
#       - lambda: return x * 9.0/5.0 + 32.0;
#     on_value:
#       then:
#         - lambda: |-
#             id(zone8_climate).current_temperature = x;

  # Failsafe error score sensors (0-100, safety error at 50+)
  - platform: template
    name: "Zone 1 Error Score"
    id: zone1_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[0];'
    update_interval: 30s

  - platform: template
    name: "Zone 2 Error Score"
    id: zone2_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[1];'
    update_interval: 30s

  - platform: template
    name: "Zone 3 Error Score"
    id: zone3_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[2];'
    update_interval: 30s

  - platform: template
    name: "Zone 4 Error Score"
    id: zone4_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[3];'
    update_interval: 30s

  - platform: template
    name: "Zone 5 Error Score"
    id: zone5_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[4];'
    update_interval: 30s

  - platform: template
    name: "Zone 6 Error Score"
    id: zone6_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[5];'
    update_interval: 30s

  - platform: template
    name: "Zone 7 Error Score"
    id: zone7_error_score
    unit_of_measurement: ""
    accuracy_decimals: 0
    lambda: 'return id(zone_error_scores)[6];'
    update_interval: 30s

  # Memory monitoring sensors
  - platform: template
    name: "Free Heap Memory"
    id: free_heap
    unit_of_measurement: "KB"
    accuracy_decimals: 1
    lambda: 'return heap_caps_get_free_size(MALLOC_CAP_INTERNAL) / 1024.0;'
    update_interval: 60s
    entity_category: diagnostic

  - platform: template
    name: "Free PSRAM"
    id: free_psram
    unit_of_measurement: "KB"
    accuracy_decimals: 1
    lambda: 'return heap_caps_get_free_size(MALLOC_CAP_SPIRAM) / 1024.0;'
    update_interval: 60s
    entity_category: diagnostic

  - platform: template
    name: "Minimum Free Heap"
    id: min_free_heap
    unit_of_measurement: "KB"
    accuracy_decimals: 1
    lambda: 'return heap_caps_get_minimum_free_size(MALLOC_CAP_INTERNAL) / 1024.0;'
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: 60s
    entity_category: diagnostic

# Text sensors for diagnostic info
text_sensor:
  - platform: template
    name: "Last Reset Reason"
    id: reset_reason_sensor
    entity_category: diagnostic
    lambda: |-
      esp_reset_reason_t reason = esp_reset_reason();
      switch (reason) {
        case ESP_RST_POWERON:   return {"Power-on"};
        case ESP_RST_EXT:       return {"External reset"};
        case ESP_RST_SW:        return {"Software reset"};
        case ESP_RST_PANIC:     return {"Exception/panic"};
        case ESP_RST_INT_WDT:   return {"Interrupt watchdog"};
        case ESP_RST_TASK_WDT:  return {"Task watchdog"};
        case ESP_RST_WDT:       return {"Watchdog"};
        case ESP_RST_DEEPSLEEP: return {"Deep sleep"};
        case ESP_RST_BROWNOUT:  return {"Brownout"};
        case ESP_RST_SDIO:      return {"SDIO"};
        default:                return {"Unknown"};
      }
    update_interval: never

# Thermostat climate entities for each zone
climate:
  - platform: thermostat
    name: "Zone 1 Thermostat"
    id: zone1_climate
    sensor: zone1_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F in Celsius
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F in Celsius
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone1_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone1_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 2 Thermostat"
    id: zone2_climate
    sensor: zone2_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone2_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone2_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 3 Thermostat"
    id: zone3_climate
    sensor: zone3_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone3_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone3_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 4 Thermostat"
    id: zone4_climate
    sensor: zone4_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone4_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone4_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 5 Thermostat"
    id: zone5_climate
    sensor: zone5_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone5_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone5_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 6 Thermostat"
    id: zone6_climate
    sensor: zone6_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone6_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone6_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

  - platform: thermostat
    name: "Zone 7 Thermostat"
    id: zone7_climate
    sensor: zone7_temp
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20  # 68°F
    min_heating_off_time: 60s
    min_heating_run_time: 60s
    min_idle_time: 30s
    heat_deadband: 0.5  # ~1°F
    heat_overrun: 0
    heat_action:
      - switch.turn_on: zone7_relay
      - script.execute: set_pump_demand
    idle_action:
      - switch.turn_off: zone7_relay
      - script.execute: set_pump_demand
    visual:
      min_temperature: 10  # 50°F
      max_temperature: 30  # 86°F
      temperature_step: 0.5

# Zone 8 thermostat available for expansion via XL9535
# Uncomment when expansion board is installed
#   - platform: thermostat
#     name: "Zone 8 Thermostat"
#     id: zone8_climate
#     sensor: zone8_temp
#     default_preset: Home
#     preset:
#       - name: Home
#         default_target_temperature_low: 68 °F
#     min_heating_off_time: 60s
#     min_heating_run_time: 60s
#     min_idle_time: 30s
#     heat_deadband: 1 °F
#     heat_overrun: 0 °F
#     heat_action:
#       - switch.turn_on: zone8_relay
#     idle_action:
#       - switch.turn_off: zone8_relay
#     visual:
#       min_temperature: 50 °F
#       max_temperature: 85 °F
#       temperature_step: 0.5 °F

# Valve feedback sensors (active when valve is open)
# These are used to interlock the circulation pump - pump only runs when at least one valve is confirmed open
# Waveshare board digital inputs DI1-DI8: GPIO4-GPIO11, active-low with internal pullups
binary_sensor:
  - platform: status
    name: "Controller Status"

  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 1 Valve Open"
    id: zone1_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 2 Valve Open"
    id: zone2_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO6
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 3 Valve Open"
    id: zone3_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO7
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 4 Valve Open"
    id: zone4_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 5 Valve Open"
    id: zone5_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 6 Valve Open"
    id: zone6_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Zone 7 Valve Open"
    id: zone7_valve
    device_class: opening
    filters:
      - delayed_on_off: 10ms
    on_state:
      then:
        - script.execute: update_pump_state

  # Digital Input 8 (DI8) available for future use (e.g., expansion zone valve feedback)
  - platform: gpio
    pin:
      number: GPIO11
      mode: INPUT_PULLUP
      inverted: true  # Active low
    name: "Digital Input 8"
    id: di8
    filters:
      - delayed_on_off: 10ms

  # Virtual sensor showing if any valve is open (for HA dashboard)
  - platform: template
    name: "Any Valve Open"
    id: any_valve_open
    device_class: opening
    lambda: |-
      return id(zone1_valve).state || id(zone2_valve).state || id(zone3_valve).state ||
             id(zone4_valve).state || id(zone5_valve).state || id(zone6_valve).state ||
             id(zone7_valve).state;

  # Pump running status (for HA dashboard)
  - platform: template
    name: "Circulation Pump Running"
    id: pump_running
    device_class: running
    lambda: |-
      return id(pump_relay).state;

# Pump control scripts
script:
  - id: update_pump_state
    mode: restart
    then:
      - lambda: |-
          // Check if any valve is open
          bool any_valve = id(zone1_valve).state || id(zone2_valve).state || id(zone3_valve).state ||
                           id(zone4_valve).state || id(zone5_valve).state || id(zone6_valve).state ||
                           id(zone7_valve).state;

          // Check if any zone is calling for heat (pump demand)
          bool heat_demand = id(pump_demand);

          if (heat_demand && any_valve) {
            // Demand exists and valve confirmed open - start pump after delay
            ESP_LOGI("pump", "Heat demand with valve open - starting pump after delay");
          } else if (!heat_demand) {
            // No heat demand - stop pump after delay
            ESP_LOGI("pump", "No heat demand - stopping pump after delay");
          } else {
            // Heat demand but no valve open yet - wait
            ESP_LOGI("pump", "Heat demand but waiting for valve to open");
          }
      - if:
          condition:
            lambda: |-
              bool any_valve = id(zone1_valve).state || id(zone2_valve).state || id(zone3_valve).state ||
                               id(zone4_valve).state || id(zone5_valve).state || id(zone6_valve).state ||
                               id(zone7_valve).state;
              return id(pump_demand) && any_valve;
          then:
            - delay: !lambda "return id(pump_start_delay).state * 1000;"
            - switch.turn_on: pump_relay
            - light.turn_on:
                id: status_led
                effect: "Heating Active"
                red: 100%
                green: 30%
                blue: 0%
          else:
            - if:
                condition:
                  lambda: 'return !id(pump_demand);'
                then:
                  - delay: !lambda "return id(pump_stop_delay).state * 1000;"
                  - switch.turn_off: pump_relay
                  - light.turn_on:
                      id: status_led
                      effect: none
                      red: 0%
                      green: 100%
                      blue: 0%

  - id: set_pump_demand
    mode: restart
    then:
      - lambda: |-
          // Check if any zone thermostat is actively heating
          bool demand = false;
          auto z1_action = id(zone1_climate).action;
          auto z2_action = id(zone2_climate).action;
          auto z3_action = id(zone3_climate).action;
          auto z4_action = id(zone4_climate).action;
          auto z5_action = id(zone5_climate).action;
          auto z6_action = id(zone6_climate).action;
          auto z7_action = id(zone7_climate).action;

          if (z1_action == climate::CLIMATE_ACTION_HEATING ||
              z2_action == climate::CLIMATE_ACTION_HEATING ||
              z3_action == climate::CLIMATE_ACTION_HEATING ||
              z4_action == climate::CLIMATE_ACTION_HEATING ||
              z5_action == climate::CLIMATE_ACTION_HEATING ||
              z6_action == climate::CLIMATE_ACTION_HEATING ||
              z7_action == climate::CLIMATE_ACTION_HEATING) {
            demand = true;
          }

          id(pump_demand) = demand;
          ESP_LOGI("pump", "Pump demand updated: %s", demand ? "true" : "false");
      - script.execute: update_pump_state

# RGB status LED (WS2812)
light:
  - platform: esp32_rmt_led_strip
    rgb_order: RGB
    chipset: WS2812
    pin: GPIO38
    num_leds: 1
    name: "Status LED"
    id: status_led
    effects:
      - pulse:
          name: "Heating Active"
          transition_length: 1s
          update_interval: 1s
      - strobe:
          name: "Fast Blink"
          colors:
            - state: true
              duration: 200ms
            - state: false
              duration: 200ms

# Time sync for logging
time:
  - platform: sntp
    id: sntp_time
    timezone: America/Los_Angeles

# Periodic status logging and LED updates
interval:
  - interval: 10s
    then:
      - lambda: |-
          // Log network status and IP address
          if (wifi::global_wifi_component->is_connected()) {
            auto ips = wifi::global_wifi_component->get_ip_addresses();
            if (!ips.empty()) {
              ESP_LOGI("status", "WiFi connected - IP: %s, RSSI: %d dBm",
                       ips[0].str().c_str(),
                       wifi::global_wifi_component->wifi_rssi());
            }
          } else {
            ESP_LOGW("status", "WiFi disconnected - attempting to connect...");
          }

          // Log sensor status
          ESP_LOGI("status", "Zone1: %.1f°C, Zone2: %.1f°C",
                   id(zone1_temp).state, id(zone2_temp).state);

          // Update LED based on status
          if (!wifi::global_wifi_component->is_connected()) {
            // Red blink = no WiFi
            auto call = id(status_led).turn_on();
            call.set_rgb(1.0, 0.0, 0.0);
            call.set_effect("Fast Blink");
            call.perform();
          } else if (id(pump_demand)) {
            // Orange pulse = heating active
            auto call = id(status_led).turn_on();
            call.set_rgb(1.0, 0.3, 0.0);
            call.set_effect("Heating Active");
            call.perform();
          } else {
            // Green = connected and idle
            auto call = id(status_led).turn_on();
            call.set_rgb(0.0, 1.0, 0.0);
            call.set_brightness(0.3);
            call.set_effect("none");
            call.perform();
          }

  # Sample temperature history and run failsafe checks (every 30 seconds)
  - interval: 30s
    then:
      - lambda: |-
          int idx = id(history_index);

          // Sample zone temperatures
          id(temp_history_1)[idx] = id(zone1_temp).state;
          id(temp_history_2)[idx] = id(zone2_temp).state;
          id(temp_history_3)[idx] = id(zone3_temp).state;
          id(temp_history_4)[idx] = id(zone4_temp).state;
          id(temp_history_5)[idx] = id(zone5_temp).state;
          id(temp_history_6)[idx] = id(zone6_temp).state;
          id(temp_history_7)[idx] = id(zone7_temp).state;

          // Sample pump status
          id(pump_history)[idx] = id(pump_relay).state;

          // Advance circular buffer index
          id(history_index) = (idx + 1) % 40;

          // === FAILSAFE MONITORING ===
          // Arrays for zone data access
          float temps[7] = {
            id(zone1_temp).state, id(zone2_temp).state, id(zone3_temp).state,
            id(zone4_temp).state, id(zone5_temp).state, id(zone6_temp).state,
            id(zone7_temp).state
          };
          bool relays[7] = {
            id(zone1_relay).state, id(zone2_relay).state, id(zone3_relay).state,
            id(zone4_relay).state, id(zone5_relay).state, id(zone6_relay).state,
            id(zone7_relay).state
          };
          bool valves[7] = {
            id(zone1_valve).state, id(zone2_valve).state, id(zone3_valve).state,
            id(zone4_valve).state, id(zone5_valve).state, id(zone6_valve).state,
            id(zone7_valve).state
          };
          bool heating[7] = {
            id(zone1_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone2_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone3_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone4_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone5_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone6_climate).action == climate::CLIMATE_ACTION_HEATING,
            id(zone7_climate).action == climate::CLIMATE_ACTION_HEATING
          };

          // Thresholds
          const int VALVE_TIMEOUT_THRESHOLD = 20;     // 20 * 30s = 10 minutes
          const int HEAT_CHECK_DELAY = 10;            // Wait 10 * 30s = 5 min before checking temp rise
          const float MIN_TEMP_RISE = 0.2;            // Expect at least 0.2°C rise
          const int ERROR_THRESHOLD = 50;             // Error score threshold for safety flag
          const int ERROR_INCREMENT = 5;              // Points added per failure
          const int ERROR_DECREMENT = 1;              // Points removed when OK

          for (int i = 0; i < 7; i++) {
            float temp = temps[i];
            bool relay_on = relays[i];
            bool valve_open = valves[i];
            bool is_heating = heating[i];
            bool sensor_valid = !std::isnan(temp) && temp > 0 && temp < 80;

            // --- Valve timeout check ---
            if (relay_on && !valve_open) {
              // Relay commanded but valve not confirmed open
              id(zone_valve_timeout)[i]++;
              if (id(zone_valve_timeout)[i] > VALVE_TIMEOUT_THRESHOLD) {
                id(zone_error_scores)[i] += ERROR_INCREMENT;
                ESP_LOGW("failsafe", "Zone %d: Valve timeout (relay on, no valve feedback)", i + 1);
              }
            } else {
              id(zone_valve_timeout)[i] = 0;  // Reset timeout counter
            }

            // --- Temperature rise check ---
            if (is_heating && valve_open && sensor_valid) {
              // Zone is actively heating with valve confirmed
              if (id(zone_heat_duration)[i] == 0) {
                // Just started heating - record reference temperature
                id(zone_heat_ref_temps)[i] = temp;
              }
              id(zone_heat_duration)[i]++;

              // After delay, check if temperature is rising
              if (id(zone_heat_duration)[i] > HEAT_CHECK_DELAY) {
                float ref_temp = id(zone_heat_ref_temps)[i];
                float temp_change = temp - ref_temp;

                if (temp_change < MIN_TEMP_RISE) {
                  // Temperature not rising as expected
                  id(zone_error_scores)[i] += ERROR_INCREMENT;
                  ESP_LOGW("failsafe", "Zone %d: No temp rise (ref=%.1f, now=%.1f, change=%.2f)",
                           i + 1, ref_temp, temp, temp_change);

                  // Reset reference to current temp for next check cycle
                  id(zone_heat_ref_temps)[i] = temp;
                  id(zone_heat_duration)[i] = HEAT_CHECK_DELAY;  // Keep checking
                } else {
                  // Temperature rising normally - decrease error score
                  if (id(zone_error_scores)[i] > 0) {
                    id(zone_error_scores)[i] -= ERROR_DECREMENT;
                  }
                  // Update reference for continued monitoring
                  id(zone_heat_ref_temps)[i] = temp;
                  id(zone_heat_duration)[i] = HEAT_CHECK_DELAY;
                }
              }
            } else {
              // Not heating - reset duration counter
              id(zone_heat_duration)[i] = 0;

              // Slowly decay error score when not heating
              if (id(zone_error_scores)[i] > 0 && !is_heating) {
                id(zone_error_scores)[i] -= ERROR_DECREMENT;
              }
            }

            // Clamp error score to valid range
            if (id(zone_error_scores)[i] < 0) id(zone_error_scores)[i] = 0;
            if (id(zone_error_scores)[i] > 100) id(zone_error_scores)[i] = 100;

            // Log if zone has safety error
            if (id(zone_error_scores)[i] >= ERROR_THRESHOLD) {
              ESP_LOGE("failsafe", "Zone %d: SAFETY ERROR (score=%d)", i + 1, id(zone_error_scores)[i]);
            }
          }

# SPI bus for TFT display (using SD Card header pins)
# SD Card header: SCLK=GPIO48, MOSI=GPIO47, MISO=GPIO45 (repurposed as CS)
spi:
  - id: display_spi
    clk_pin: GPIO48   # SD Card SCLK
    mosi_pin: GPIO47  # SD Card MOSI

# Fonts for display
font:
  - file: "gfonts://Roboto"
    id: font_xlarge
    size: 20
  - file: "gfonts://Roboto"
    id: font_large
    size: 16
  - file: "gfonts://Roboto"
    id: font_medium
    size: 12
  - file: "gfonts://Roboto"
    id: font_small
    size: 10
  - file: "gfonts://Roboto"
    id: font_tiny
    size: 8

# 2.2" ILI9341 TFT Display (320x240)
display:
  - platform: ili9xxx
    model: ILI9341
    spi_id: display_spi
    cs_pin: GPIO45    # SD Card MISO (repurposed, display is write-only)
    dc_pin: GPIO21
    reset_pin: GPIO1
    dimensions: [240, 320]
    rotation: 270
    invert_colors: false
    update_interval: 1s
    lambda: |-
      // Colors
      auto WHITE = Color(255, 255, 255);
      auto BLACK = Color(0, 0, 0);
      auto RED = Color(255, 0, 0);
      auto GREEN = Color(0, 255, 0);
      auto BLUE = Color(0, 120, 255);
      auto ORANGE = Color(255, 165, 0);
      auto GRAY = Color(128, 128, 128);
      auto DARK_GRAY = Color(48, 48, 48);
      auto LIGHT_GRAY = Color(80, 80, 80);

      // Clear screen
      it.fill(BLACK);

      // Layout constants
      int box_width = 40;
      int box_height = 78;  // Taller boxes for better readability
      int graph_height = 84;  // Double height for better visibility
      int graph_y = box_height;
      int status_y = box_height + graph_height + 4;
      float graph_range = 6.0;  // ±6°C range (12°C total)

      // Get global setpoint and hysteresis
      float global_sp = id(global_setpoint).state;
      float hyst = id(hysteresis).state;
      int hist_idx = id(history_index);

      // Helper arrays for zone data access
      float temps[7] = {
        id(zone1_temp).state, id(zone2_temp).state, id(zone3_temp).state,
        id(zone4_temp).state, id(zone5_temp).state, id(zone6_temp).state,
        id(zone7_temp).state
      };
      // Per-zone setpoints from thermostats
      float setpoints[7] = {
        id(zone1_climate).target_temperature, id(zone2_climate).target_temperature,
        id(zone3_climate).target_temperature, id(zone4_climate).target_temperature,
        id(zone5_climate).target_temperature, id(zone6_climate).target_temperature,
        id(zone7_climate).target_temperature
      };
      bool relays[7] = {
        id(zone1_relay).state, id(zone2_relay).state, id(zone3_relay).state,
        id(zone4_relay).state, id(zone5_relay).state, id(zone6_relay).state,
        id(zone7_relay).state
      };
      bool valves[7] = {
        id(zone1_valve).state, id(zone2_valve).state, id(zone3_valve).state,
        id(zone4_valve).state, id(zone5_valve).state, id(zone6_valve).state,
        id(zone7_valve).state
      };
      bool heating[7] = {
        id(zone1_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone2_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone3_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone4_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone5_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone6_climate).action == climate::CLIMATE_ACTION_HEATING,
        id(zone7_climate).action == climate::CLIMATE_ACTION_HEATING
      };
      float* histories[7] = {
        id(temp_history_1), id(temp_history_2), id(temp_history_3),
        id(temp_history_4), id(temp_history_5), id(temp_history_6),
        id(temp_history_7)
      };

      // Draw zone boxes (7 zones)
      for (int i = 0; i < 7; i++) {
        int x = i * box_width;
        float temp = temps[i];
        bool relay_on = relays[i];
        bool valve_open = valves[i];
        bool is_heating = heating[i];

        // Determine sensor status
        bool sensor_missing = std::isnan(temp);
        bool sensor_error = (!sensor_missing && (temp >= 84.5 && temp <= 85.5));  // 85°C = power-on reset
        bool safety_error = (id(zone_error_scores)[i] >= 50);  // Error score threshold

        // Determine colors based on status
        Color outline_color = WHITE;
        Color text_color = WHITE;
        Color bg_color = DARK_GRAY;

        if (sensor_missing) {
          outline_color = GRAY;
          text_color = GRAY;
        } else if (sensor_error) {
          outline_color = RED;
        } else if (safety_error) {
          bg_color = RED;
        } else if (is_heating) {
          bg_color = ORANGE;
        }

        // Draw box background and outline
        it.filled_rectangle(x, 0, box_width - 1, box_height, bg_color);
        it.rectangle(x, 0, box_width - 1, box_height, outline_color);

        // Zone number (top left, tiny)
        it.printf(x + 2, 1, id(font_tiny), text_color, "Z%d", i + 1);

        // Temperature (large, centered)
        if (!sensor_missing) {
          it.printf(x + 3, 10, id(font_xlarge), text_color, "%.0f", temp);
        } else {
          it.print(x + 8, 14, id(font_large), GRAY, "--");
        }

        // Setpoint (below temp) - use zone-specific setpoint
        float zone_sp = setpoints[i];
        it.printf(x + 2, 32, id(font_small), text_color, "set:%.0f", zone_sp);

        // HEAT indicator row
        int heat_y = 48;
        if (is_heating) {
          it.filled_circle(x + 6, heat_y + 4, 3, RED);
        } else {
          it.circle(x + 6, heat_y + 4, 3, GRAY);
        }
        it.print(x + 12, heat_y, id(font_tiny), is_heating ? RED : GRAY, "HEAT");

        // VALV indicator row
        int valv_y = 62;
        if (valve_open) {
          it.filled_circle(x + 6, valv_y + 4, 3, BLUE);
        } else {
          it.circle(x + 6, valv_y + 4, 3, GRAY);
        }
        it.print(x + 12, valv_y, id(font_tiny), valve_open ? BLUE : GRAY, "VALV");

        // Draw temperature graph below box
        int gx = x;
        int gy = graph_y;
        int gw = box_width - 1;
        int gh = graph_height;

        // Graph background
        it.filled_rectangle(gx, gy, gw, gh, BLACK);
        it.rectangle(gx, gy, gw, gh, sensor_missing ? DARK_GRAY : LIGHT_GRAY);

        // Skip graph content for inactive zones (no sensor)
        if (!sensor_missing) {
          // Graph scale: center on zone setpoint, ±graph_range
          float graph_min = zone_sp - graph_range;
          float graph_max = zone_sp + graph_range;
          float total_range = graph_range * 2.0;

          // Draw setpoint line (center)
          int sp_y = gy + gh / 2;
          it.line(gx + 1, sp_y, gx + gw - 2, sp_y, GRAY);

          // Draw hysteresis lines
          int hyst_upper_y = gy + (int)((graph_max - (zone_sp + hyst)) / total_range * gh);
          int hyst_lower_y = gy + (int)((graph_max - (zone_sp - hyst)) / total_range * gh);
          if (hyst_upper_y >= gy && hyst_upper_y < gy + gh) {
            for (int px = gx + 2; px < gx + gw - 2; px += 3) {
              it.draw_pixel_at(px, hyst_upper_y, LIGHT_GRAY);
            }
          }
          if (hyst_lower_y >= gy && hyst_lower_y < gy + gh) {
            for (int px = gx + 2; px < gx + gw - 2; px += 3) {
              it.draw_pixel_at(px, hyst_lower_y, LIGHT_GRAY);
            }
          }

          // Draw temperature history line
          float* hist = histories[i];
          int prev_py = -1;
          for (int s = 0; s < 40; s++) {
            // Read from circular buffer (oldest to newest)
            int idx = (hist_idx + s) % 40;
            float val = hist[idx];
            if (std::isnan(val) || val < 0 || val > 100) continue;

            // Map value to pixel Y
            int py = gy + (int)((graph_max - val) / total_range * gh);
            py = std::max(gy + 1, std::min(gy + gh - 2, py));

            // Map sample to pixel X
            int px = gx + 1 + (s * (gw - 3)) / 39;

            if (prev_py >= 0 && s > 0) {
              it.line(gx + 1 + ((s-1) * (gw - 3)) / 39, prev_py, px, py, GREEN);
            }
            prev_py = py;
          }
        }
      }

      // Pump box (8th position)
      int pump_x = 7 * box_width;
      bool pump_on = id(pump_relay).state;
      Color pump_bg = pump_on ? BLUE : DARK_GRAY;
      Color pump_outline = WHITE;

      it.filled_rectangle(pump_x, 0, box_width - 1, box_height, pump_bg);
      it.rectangle(pump_x, 0, box_width - 1, box_height, pump_outline);

      // Pump label
      it.print(pump_x + 4, 2, id(font_small), WHITE, "PUMP");

      // Pump status (large)
      it.printf(pump_x + 6, 18, id(font_large), pump_on ? WHITE : GRAY, "%s", pump_on ? "ON" : "OFF");

      // Pump demand indicator
      int pdem_y = 48;
      if (id(pump_demand)) {
        it.filled_circle(pump_x + 6, pdem_y + 4, 3, ORANGE);
      } else {
        it.circle(pump_x + 6, pdem_y + 4, 3, GRAY);
      }
      it.print(pump_x + 12, pdem_y, id(font_tiny), id(pump_demand) ? ORANGE : GRAY, "DMD");

      // Relay status indicator
      int prel_y = 62;
      if (pump_on) {
        it.filled_circle(pump_x + 6, prel_y + 4, 3, GREEN);
      } else {
        it.circle(pump_x + 6, prel_y + 4, 3, GRAY);
      }
      it.print(pump_x + 12, prel_y, id(font_tiny), pump_on ? GREEN : GRAY, "RLY");

      // Pump binary graph
      int pgx = pump_x;
      int pgy = graph_y;
      int pgw = box_width - 1;
      int pgh = graph_height;

      it.filled_rectangle(pgx, pgy, pgw, pgh, BLACK);
      it.rectangle(pgx, pgy, pgw, pgh, LIGHT_GRAY);

      // Draw pump history as filled bars
      for (int s = 0; s < 40; s++) {
        int idx = (hist_idx + s) % 40;
        bool on = id(pump_history)[idx];
        int px = pgx + 1 + (s * (pgw - 3)) / 39;
        if (on) {
          it.line(px, pgy + 2, px, pgy + pgh - 3, BLUE);
        }
      }

      // Status bar at bottom
      // Line 1: Network status
      it.print(5, status_y, id(font_small), WHITE, "Net:");
      if (wifi::global_wifi_component->is_connected()) {
        auto ips = wifi::global_wifi_component->get_ip_addresses();
        if (!ips.empty()) {
          it.printf(30, status_y, id(font_small), GREEN, "%s", ips[0].str().c_str());
        }
        it.printf(145, status_y, id(font_tiny), GRAY, "RSSI:%d", wifi::global_wifi_component->wifi_rssi());
      } else {
        it.print(30, status_y, id(font_small), RED, "DISCONNECTED");
      }

      // Line 2: Time and global setpoint
      int line2_y = status_y + 14;
      if (id(sntp_time).now().is_valid()) {
        it.strftime(5, line2_y, id(font_small), WHITE, "%Y-%m-%d %H:%M:%S", id(sntp_time).now());
      }
      it.printf(200, line2_y, id(font_small), WHITE, "Set:%.1f°C", global_sp);

      // Line 3: Demand and valve summary
      int line3_y = line2_y + 14;
      it.print(5, line3_y, id(font_small), WHITE, "Demand:");
      it.printf(55, line3_y, id(font_small), id(pump_demand) ? ORANGE : GRAY, "%s", id(pump_demand) ? "ACTIVE" : "idle");

      bool any_valve = valves[0] || valves[1] || valves[2] || valves[3] || valves[4] || valves[5] || valves[6];
      it.print(120, line3_y, id(font_small), WHITE, "Valves:");
      it.printf(170, line3_y, id(font_small), any_valve ? GREEN : GRAY, "%s", any_valve ? "OPEN" : "closed");

      // Count active zones
      int active_count = 0;
      for (int i = 0; i < 7; i++) if (heating[i]) active_count++;
      it.printf(240, line3_y, id(font_small), active_count > 0 ? ORANGE : GRAY, "Zones:%d", active_count);
